// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System;
using System.IO;

public class RobotSim : ModuleRules
{
    public const String EIGEN_INCLUDE_DIR = "/Users/mroberts/code/github/interiorsim/code/third_party/libeigen";

    public const String RBDL_INCLUDE_DIR = "/Users/mroberts/code/github/interiorsim/code/third_party/rbdl/include";
    public const String RBDL_CONFIG_INCLUDE_DIR = "/Users/mroberts/code/github/interiorsim/code/third_party/rbdl/build/include";
    public const String RBDL_URDF_READER_INCLUDE_DIR = "/Users/mroberts/code/github/interiorsim/code/third_party";
    public const String RBDL_LIB = "/Users/mroberts/code/github/interiorsim/code/third_party/rbdl/build/librbdl.a";
    public const String RBDL_URDF_READER_LIB = "/Users/mroberts/code/github/interiorsim/code/third_party/rbdl/build/addons/urdfreader/librbdl_urdfreader.a";

    public RobotSim(ReadOnlyTargetRules Target) : base(Target)
    {
        // module settings
        OptimizeCode = CodeOptimization.Never;
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
        bEnableExceptions = true;

        PublicIncludePaths.AddRange(new string[] {} );
        PrivateIncludePaths.AddRange(new string[] {} );
        
        PublicDependencyModuleNames.AddRange(new string[] {
            "APEX", "Core", "CoreUObject", "Engine", "Foliage", "InputCore", "ImageWrapper", "NavigationSystem", "PhysicsCore", "PhysX",
            "PhysXVehicles", "PhysXVehicleLib", "ProceduralMeshComponent", "Landscape", "RenderCore", "RHI", "Slate", "SlateCore", "UMG", "XmlParser", 
        } );
        PrivateDependencyModuleNames.AddRange(new string[] {} );

        //
        // Eigen
        //

        PublicIncludePaths.Add(EIGEN_INCLUDE_DIR);
        
        //
        // RBDL
        //

        PublicIncludePaths.Add(RBDL_INCLUDE_DIR);
        PublicIncludePaths.Add(RBDL_CONFIG_INCLUDE_DIR);
        PublicIncludePaths.Add(RBDL_URDF_READER_INCLUDE_DIR);
        PublicAdditionalLibraries.Add(RBDL_LIB);
        PublicAdditionalLibraries.Add(RBDL_URDF_READER_LIB);

        //
        // VHACD (we can't take care of this unpleasant platform-specific logic using constant strings because it depends on Target)
        //

        string VHACDDirectory = Target.UEThirdPartySourceDirectory + "VHACD/";
        string VHACDLibPath = VHACDDirectory;
        PublicIncludePaths.Add(VHACDDirectory + "public");

        if (Target.Platform == UnrealTargetPlatform.Win64) {
            VHACDLibPath = VHACDLibPath + "lib/Win64/VS" + Target.WindowsPlatform.GetVisualStudioCompilerVersionName() + "/";
            PublicLibraryPaths.Add(VHACDLibPath);

            if (Target.Configuration == UnrealTargetConfiguration.Debug && Target.bDebugBuildsActuallyUseDebugCRT) {
                PublicAdditionalLibraries.Add("VHACDd.lib");
            }
            else {
                PublicAdditionalLibraries.Add("VHACD.lib");
            }
        }
        else if (Target.Platform == UnrealTargetPlatform.Mac) {
            string LibPath = VHACDDirectory + "Lib/Mac/";
            if (Target.Configuration == UnrealTargetConfiguration.Debug && Target.bDebugBuildsActuallyUseDebugCRT) {
                PublicAdditionalLibraries.Add(LibPath + "libVHACD_LIBd.a");
            }
            else {
                PublicAdditionalLibraries.Add(LibPath + "libVHACD_LIB.a");
            }
            PublicFrameworks.AddRange(new string[] { "OpenCL" });
        }
        else if (Target.Platform == UnrealTargetPlatform.Linux) {
            if (Target.LinkType == TargetLinkType.Monolithic) {
                PublicAdditionalLibraries.Add(VHACDDirectory + "Lib/Linux/" + Target.Architecture + "/libVHACD.a");
            }
            else {
                PublicAdditionalLibraries.Add(VHACDDirectory + "Lib/Linux/" + Target.Architecture + "/libVHACD_fPIC.a");
            }
        }
    }
}
